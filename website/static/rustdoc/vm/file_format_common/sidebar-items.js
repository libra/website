initSidebarItems({"enum":[["Opcodes","List of Opcodes"],["SerializedType","Signature blob values"],["SignatureType","Signature types. Those values start a signature blob"],["TableType","Table types in the binary. The header of the binary contains a subset of those tables. The header records (table type, start offset, count) for a given table"]],"fn":[["read_u16","Read a u16 in Little Endian format from the slice in input"],["read_u32","Read a u32 in Little Endian format from the slice in input"],["read_u64","Read a u64 in Little Endian format from the slice in input"],["read_uleb128_as_u16","Take a &[u8] slice and return a pair: usize - of how many bytes were consumed, u16 - value Return an error on an invalid representation."],["read_uleb128_as_u32","Take a &[u8] slice and return a pair: usize - of how many bytes were consumed, u32 - value Return an error on an invalid representation."],["write_u16","Write a u16 in Little Endian format"],["write_u16_as_uleb128","LEB128 is a compressed representation for integer values from the DWARF3 spec, http://dwarfstd.org/Dwarf3Std.php or https://en.wikipedia.org/wiki/LEB128. It's used to compress mostly indexes into the main file format tables. Take a Vec and a value to write to that vector and applies LEB128 logic to compress the u16"],["write_u32","Write a u32 in Little Endian format"],["write_u32_as_uleb128","Take a Vec and a value to write to that vector and applies LEB128 logic to compress the u32"],["write_u64","Write a u64 in Little Endian format"]],"struct":[["BinaryConstants","Constant values for the binary format"]]});