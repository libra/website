initSidebarItems({"enum":[["Kind","Denotes the copy-ability of \"collection\"-like items. Resource items represent unique assets that should not be copied Value items represent buildes of other value items that can be copied freely"],["SimpleValue",""],["StoredItem","Here's a quick diagram of how the program talks to the states on chain: `text +-----------------------------------+ | StateDB | Top level of storage hierarchy, where states are being stored on chain as bytes. +-----------------------------------+ | |Read raw bytes, |Parse into StoredItem | v +-----------------------------------+ Layer that talks to global storage directly, and performs all the serialization/ | GlobalStorageAdapter | deserialization jobs. +-----------------------------------+ | | | | For all read that is not in the cache, we will use global storage adapter to |read_value | read_struct_class resolve them in the storagedb. | | v v +-----------------------------------+ Layer that caches all the global reads and modifications. We will use this layer | GlobalStorageCache | to generate read sets and write sets as well at the end of a successful struct +-----------------------------------+ execution. | | ^ | | | |read_value |read_code |write_value | | | v v | +-----------------------------------+ Wrapper for all memory related operation that a program can do to the storagedb. | ExecutionContext | +-----------------------------------+` This enum describes how values are stored internally in the statedb. CopyableVal are simple primitive items like int/bool etc. Code holds the raw code implementation of the struct. Structs are a bit more tricky. They acts like the root node in the tree. I'll explain the how it works more in the following example: Similarly, if we have a Value::Struct(kind, type_, data) under 0x1 with accesses \"data\" where data is {f: {g: 1, h: true}}, we'll store following to statedb: 0x1/data : Struct(kind, type_), 0x1/data/g : Int(1), 0x1/data/h : Bool(true), Same schema is used in SimpleStorageCache to reflect how data is stored in the statedb. Having a Struct/Resource tag essentially means that everything underneath such access is part of the struct/resource value, and all fields of the struct/resource is already cached/stored in the statedb. So this is going to be a bidirectional statement."],["Value",""]],"struct":[["CodeKey","Represents the intitial key into global storage where we first index by the address, and then the struct tag"],["ResourceKey","Represents the intitial key into global storage where we first index by the address, and then the struct tag"],["StructTag",""]]});